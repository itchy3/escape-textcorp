// (추가) 공통 리셋 함수
const resetStats = () => {
  updateBar(hpBar, hpText, 0, 100, false);
  updateBar(hungerBar, hungerText, 0, 100, false);
  // 맞춤스탯은 최대치 모를 수 있으니 표시만 초기화
  customBar.style.width = "0%";
  customText.textContent = "0/0";
  const customOverlay = customBar.parentElement.querySelector(".bar-text");
  if (customOverlay) customOverlay.textContent = "0/0";
  customLabel.textContent = "맞춤스탯";

  updateBar(escapeBar, escapeText, 0, 100, true);
};

// (수정) AI 응답 처리 직전 리셋 → 그 다음에 실제 텍스트로 갱신
const handleAIResponse = (text) => {
  hiddenPrompt = text;
  choices.innerHTML = "";
  resetStats();                // <-- 먼저 0으로 초기화
  updateStatsFromText(text);   // <-- 그리고 텍스트에서 찾아 반영

  const opts = extractChoices(text);
  if (opts.length) {
    opts.forEach(({ id, label }) => {
      const btn = document.createElement("button");
      btn.className = "choice-btn";
      btn.textContent = `${id} ${label}`;
      btn.onclick = () => {
        appendLog(`${id} ${label}`, "user");
        sendMessage(`선택: ${id}`);
      };
      choices.appendChild(btn);
    });
  }
};

// (수정) 시작 버튼 클릭 시도 0으로 강제 초기화 후 상태창 표시
sendBtn.onclick = () => {
  const item = itemInput.value.trim();
  if (!item) return alert("아이템을 입력하세요!");
  if (item.length > 10) return alert("10자 이내로 입력하세요.");

  appendLog(item, "user");
  resetStats();                // <-- 시작 직전 0으로 초기화
  statsEl.style.display = "block";
  inputArea.style.display = "none";
  sendMessage(`아이템으로 '${item}'을 선택합니다.`);
};

// (강화) 텍스트 파싱: 줄 시작 기준, % 허용
const updateStatsFromText = (text) => {
  // 줄 기준으로 파싱(라벨이 줄 맨 앞에 있을 때만 인식)
  const line = (label) => {
    const r = new RegExp(`^\\s*${label}\\s*[:：]?\\s*([0-9]+)%?\\s*$`, "m");
    const m = text.match(r);
    return m ? parseInt(m[1], 10) : null;
  };

  const hpVal = line("체력");
  const hungerVal = line("허기");
  const escapeVal = line("탈출\\s*상황"); // 공백 허용

  if (hpVal !== null) updateBar(hpBar, hpText, hpVal, 100, false);
  if (hungerVal !== null) updateBar(hungerBar, hungerText, hungerVal, 100, false);

  // 맞춤스탯: "맞춤스탯: 16/16" 또는 "총알: 16/16" 같은 라벨/분수 패턴
  // 우선 "맞춤스탯" 우선 매칭
  let m = text.match(/^\s*(맞춤\s*스탯|맞춤스탯)\s*[:：]\s*(\d+)\s*\/\s*(\d+)\s*$/m);
  if (!m) {
    // 그 다음 일반 라벨:숫자/숫자 포맷(예: "총알: 16/16", "액체: 200/200")
    m = text.match(/^\s*([가-힣A-Za-z0-9_]+)\s*[:：]\s*(\d+)\s*\/\s*(\d+)\s*$/m);
  }
  if (m) {
    const labelName = m[1].replace(/\s+/g, "");
    const cur = parseInt(m[2], 10);
    const max = parseInt(m[3], 10);
    customLabel.textContent = labelName;
    updateBar(customBar, customText, cur, max, false);
  }

  // 탈출상황은 라벨이 있을 때만 갱신 (없으면 0 유지)
  if (escapeVal !== null) updateBar(escapeBar, escapeText, escapeVal, 100, true);
};
